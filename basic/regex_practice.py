# -*-coding:utf-8 -*-
# File :regex_demo.py
# Author:George
# Date : 2019/10/10
# motto: Someone always give up while someone always try!
import re

# 需求: 匹配所有的 'hi' metacharacter \b 元字符 只匹配一个位置 不匹配单词分隔符中的任何一个
string = "hi, this is our history teacher, his name is steven ! hi! steven! nice to meet you "

pat = re.compile(r'\bhi\b')
# pat = re.compile(r'\bhi') # ['hi', 'hi', 'hi', 'hi']
result_hi = pat.findall(string)
print(result_hi)

# demand 找到 hi 后面不远处跟着的steven . metacharacter 匹配除换行符之外的任意字符
pat = re.compile(r'\bhi\b.*\bsteven\b')
result = pat.findall(string)
print(result)  # 会匹配['hi * steven']

# * 同样也是元字符 metacharacter 不过它代表的不是字符，也不是位置，而是数量 * 指定 *前边的内容可以连续重复使用任意次数以使整个表达式得以匹配 因此 .* 两个连在一起就是可以匹配任意长度不换行的字符串
# + metacharacter 元字符 同样代表匹配次数 贪婪匹配 代表匹配1次或者多次

# \d也是个元字符 代表匹配数字相当于[0~9]
talk = 'this is 3 ,and that is 7'
num = re.compile(r'\d')
result = num.findall(talk)
print(result)

# \s metacharacter 匹配任意的空白符、包括空格，制表符(Tab)，换行符中文全角空格 space
doc = 'hello    ! this is how we will grow up!'
result = re.compile(r'\s').findall(doc)
print(result.count(' '))

# \w 匹配字母或者数字或者下划线或者汉字 \bt\w*\b 匹配以t开头的单词  单词中可以包含\w 下划线 数字 汉字
word = re.compile(r'\bt\w*\b')
words = 'hello! everyone this is 32 the_ student s thisOne_32_哈 is really great'
result = word.findall(words)
print(result)

# \d+ 匹配一次或多次连续的数字

# \b\w{6}\b 匹配长度为6的单词
archive = 'this is our freedom also it is all our human beings progress'
word = re.compile(r'\b\w{3}\b')
result = word.findall(archive)  # ['our', 'all', 'our']
print(result)

# ^ metacharacter 匹配字符串开始的位置
# $ metacharacter 匹配字符串结束的位置
# 限制输出长度为 5~12 ^\d{5,12}$  匹配数字类型 匹配次数为不少于5次 不多于12次

"""
    如果你向查找的是元字符本身的话，比如你想查找 '*', '.'等 我们没有办法指定他们，因为他们会被解释为其他的意思 这时就得使用\来消除这些字符的特殊意义，将元字符进行转义 即为使用 \.和 \*，就算要查找\本身 也得使用\\
"""
# deerChao\.net 匹配 deerChao.net   C:\\Windows 匹配 C:\\Windows

# 匹配次数
"""
    *        匹配0次或者多次 贪婪匹配
    +        匹配1次或者多次 贪婪匹配
    ？        匹配0次或者1次  非贪婪匹配
    {n}       匹配指定次数n次
    {n,}      匹配n次或者更多次
    {n,m}     匹配n到m次 两边闭合
"""
# Windows\d+ 匹配一次或者多次              ^\w+

"""
    字符类
    按照字符类型可以将字符串元素分为: 字母、数字、空白 
    当想匹配没有预定义的字符集合 只需要在方括号中列出他们就可以了
"""
# [aeiou] 匹配任何一个英文元音字母
# [.?!] 匹配标点符号(.或者？或者！)
# [0-9] 代表匹配数字 与\d 一致
# [a-z0-9A-Z] 也几乎等同于\w (下划线和中文)


punctuation = re.compile(r'[.?!]')  # 放在[]里面相当与已经被转义了 不需要再转义
string = 'hello ! everyone. i am happy to be with yours here is not it ?'
result = punctuation.findall(string)
print(result)

# \(?0\d{2}[)-]?\d{8}
"""
    第一步: \( \对左括号转义 ? 表示左括号只能出现0次或者1次
    第二步： \d{2}匹配两次数字
    第三步： 匹配中括号[]中的 ')' 或者 '-' 0次或者1次
    第四步：\d{8} 匹配八次数字 这是可以匹配常见的几个格式的电话
"""
tel = '(010)12345678, (05612345678, 01212345678,01445789454fd'
pat = re.compile(r'\(?0\d{2}[)-]?\d{8}')
result = pat.findall(tel)
print(result)

# 分支条件
"""
    很明显 上面的表达式会匹配到 '(05612345678' 这样不正确的格式 要解决这个问题 我们需要用到分支条件
    正则表达式中的分支条件指的是有几种规则，如果满足其中任意一种都应当匹配，具体方法是用 | 将不同的规则分开 将可能的情况列举出来 避免残缺不全的匹配
"""
# 0\d{2}-\d{8}|0\d{3}-\d{7} 可以匹配三位区号(027-12345678)和四位区号(0123-1234567)的电话号码
# \(0\d{2}\)[- ]\d{8}|0\d{2}[- ]?\d{8}  通过如此设置 确保不会出现括号不完整同时能匹配正确格式
# \d{5}-\d{4}|\d{5} 这个表达式用于匹配美国的邮政编码 要么是5位数字 要么是用连字号间隔的9位数 注意各个条件的顺序 如果是 \d{5}|\d{5}-\d{4}则只会匹配5位邮编 原因是匹配分支条件时 将会从左到右的测试每个条件时 满足某个分支的条件时 就不会去管其他分支的条件

"""
    分组:我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作

"""
# (\d{1,3}\.){3}d{1,3}  简单的ip地址匹配表达式
"""
    第一步：匹配1到3位数字 \d{1,3}
    第二步：(\d{1,3}\.){3}匹配1到三位数字加上一个小数点 匹配三次 分组三次
    第三步：(\d{1, 3}\.){3}\d{1,3} 再加上一个一到三位数字
    不幸的是 它也将匹配256.300.888.999这种不存在的ip地址 只有选择分组来解决这个问题
    ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
    详细步骤: 因为ip地址每一个数字是不会超过256的 所以需要将数字256的范围进行分组列出
    第一步:列出200-249的情况 2[0-4]\d
    第二步:列出250-255的情况 25[0-5]
    第三步:列出200以下0以上的情况 [01]?\d\d?
    第四步: 将三种分组情况综合起来 对比三次 记得前面三次是带.的 需要加转义
    所以完善的ip匹配正则表达式为:
    ((2[0-4]\d|25[0-5]|[01]?\d\d?\.)){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
"""
#                           ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
ip_pattern = re.compile(r'(((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?))')
ip_list = '127.0.0.1, 136.56.457.1, 22.22.22.22, 256.256.256.256, 135.168.90.25'
valid_ip = ip_pattern.findall(ip_list)
print(valid_ip)

"""
    反义:有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：
    \W:         匹配任何不是数字、字母、下划线、汉字的字符
    \S          匹配任何不是空白字符的字符
    \D          匹配任何非数字的字符
    \B          匹配任何不是单词开头或者结尾的位置
    [^X]        匹配除了x意外的任意字符
    [^aeiou]    匹配除了aeiou这几个字符以外的任意字符
    eg: \S+ 匹配1次或者多次不是空白符的字符
        <a[^>]+> 匹配以尖括号括起来的以a开头的不包含'>'的字符串
"""

"""
    后向引用  使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。
    后向引用用于重复搜索前面某个分组匹配的文本 例如，\1代表分组1匹配的文本
    \b(\w+)\b\s+\1\b 可以用来匹配重复的单词 比如:go go kitty kitty 这个表达式首先是一个单词，也就是在单词开始出和结束出之间的多于的一个字母或者数字(\b\w+\b),或被捕获到编号位1的分组中，然后是1个或者几个空白符，最后是分组1捕获的内容
    我们也可以自己指定子表达式的组名 指定一个子表达式的组名 使用语法:(?<Word>\w+)(或者把前括号换成"也可以)(?"Word"\w+))这样就把\w+的组名指定为Word了 要反向引用这个分组抓获的内容 可以使用\k<Word>,所以上一个例子可以写成:
    \b(?<Word>\w+)\b\s+\k<Word>\b
"""
double_word = re.compile(r'\b(\w+)\b\s+\1\b')  # 为什么要加上个()呢？？？
doc = 'hei hei kitty kitty i am here look at that beautiful girl'
result = double_word.findall(doc)
print(result)  # ['hei', 'kitty']
"""
    零宽断言:断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。
    接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言 
    ?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp
    比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。
    (?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。


"""
"""
    负向零宽断言  但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：

\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。
    请详细分析表达式(?<=<(\w+)>).*(?=<\/\1>)，这个表达式最能表现零宽断言的真正用途
    同理，我们可以用(?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字。
    一个更复杂的例子：(?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\w+)>)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。
"""
"""
    注释: 小括号的另一种用途是通过语法(?#comment)来包含注释 例如:2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)
    要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样
    (?<=    # 断言要匹配的文本的前缀
      <(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
      )       # 前缀结束
      .*      # 匹配任意文本
      (?=     # 断言要匹配的文本的后缀
      <\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
      )       # 后缀结束
"""
"""
    贪婪与懒惰: 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
    有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符
    前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复
    a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符)
    *?      重复任意次 但是尽可能少重复
    +?      重复1次或者更多次，但尽可能少重复
    ??      重复0次或者1次 但尽可能少重复
    {n, m}  重复n到m次 但是尽可能少重复
    {n,}?   重复n次以上 但是尽可能少重复
    为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。
"""
string = 'aabab'
# pat_greek = re.compile(r'a.*b')
# result_greek = pat_greek.findall(string)
# print(result_greek)
pat_notGreek = re.compile(r'a.*b?')
result_notGreek = pat_notGreek.findall(string)
print(result_notGreek)  # ['aabab'] ????
"""
    处理选项: 上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：
    IgnoreCase(忽略大小写)	匹配时不区分大小写
    Multiline(多行模式)      更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.
    Singleline(单行模式)    更改.的含义，使它与每一个字符匹配（包括换行符\n）
    IgnorePatternWhitespace(忽略空白)  忽略表达式中的非转义空白并启用由#标记的注释
     ExplicitCapture(显式捕获)   仅捕获已被显式命名的组。
"""
"""
    平衡组/递归匹配
    这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法
    平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>
"""
"""
    其他:
    \a	报警字符(打印它的效果是电脑嘀一声)
    \b	通常是单词分界位置，但如果在字符类里使用代表退格
    \t	制表符，Tab
    \r	回车
    \v	竖向制表符
    \f	换页符
    \n	换行符
    \e	Escape
    \0nn	ASCII代码中八进制代码为nn的字符
    # \ xnn	ASCII代码中十六进制代码为nn的字符
    # \ u n n n n	Unicode代码中十六进制代码为nnnn的字符
    \cN	ASCII控制字符 比如\cC代表Ctrl+C
    \A	字符串开头(类似^，但不受处理多行选项的影响)
    \Z	字符串结尾或行尾(不受处理多行选项的影响)
    \z	字符串结尾(类似$，但不受处理多行选项的影响)
    \G	当前搜索的开头
    \p{name}	Unicode中命名为name的字符类
    (?>exp)	贪婪子表达式
    (?<x>-<y>exp)	平衡组
    (?im-nsx:exp)	在子表达式exp中改变处理选项
    (?im-nsx)	为表达式后面的部分改变处理选项
    (?(exp)yes|no)	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
    (?(exp)yes)	同上，只是使用空表达式作为no
    (?(name)yes|no)	如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
    (?(name)yes)	同上，只是使用空表达式作为no

"""
